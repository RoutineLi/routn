/*************************************************************************
	> File Name: HTTP.h
	> Author: lpj
	> Mail: lipeijie@vrvmail.com.cn
	> Created Time: 2022年11月08日 星期二 15时07分20秒
 ************************************************************************/

#ifndef _HTTP_H
#define _HTTP_H


#include <map>
#include <memory>
#include <vector>
#include <cstring>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>
#include <boost/lexical_cast.hpp>

/**
 * Under both headers' Source-code by Justin Karneges
 * Generated by ragel
**/
#include "http11_parser.h"
#include "httpclient_parser.h"

//GET /uri HTTP/1.1
//Host: www.baidu.com

//HTTP/1.0 200 OK
//Pragma: no-cache
//Content-Type: text/html
//Content-Length: 14988
//Connection: keep-alive

namespace Routn
{
	namespace Http
	{

/* Status Codes */
#define HTTP_STATUS_MAP(XX)                                                   \
	XX(100, CONTINUE, Continue)                                               \
	XX(101, SWITCHING_PROTOCOLS, Switching Protocols)                         \
	XX(102, PROCESSING, Processing)                                           \
	XX(200, OK, OK)                                                           \
	XX(201, CREATED, Created)                                                 \
	XX(202, ACCEPTED, Accepted)                                               \
	XX(203, NON_AUTHORITATIVE_INFORMATION, Non - Authoritative Information)   \
	XX(204, NO_CONTENT, No Content)                                           \
	XX(205, RESET_CONTENT, Reset Content)                                     \
	XX(206, PARTIAL_CONTENT, Partial Content)                                 \
	XX(207, MULTI_STATUS, Multi - Status)                                     \
	XX(208, ALREADY_REPORTED, Already Reported)                               \
	XX(226, IM_USED, IM Used)                                                 \
	XX(300, MULTIPLE_CHOICES, Multiple Choices)                               \
	XX(301, MOVED_PERMANENTLY, Moved Permanently)                             \
	XX(302, FOUND, Found)                                                     \
	XX(303, SEE_OTHER, See Other)                                             \
	XX(304, NOT_MODIFIED, Not Modified)                                       \
	XX(305, USE_PROXY, Use Proxy)                                             \
	XX(307, TEMPORARY_REDIRECT, Temporary Redirect)                           \
	XX(308, PERMANENT_REDIRECT, Permanent Redirect)                           \
	XX(400, BAD_REQUEST, Bad Request)                                         \
	XX(401, UNAUTHORIZED, Unauthorized)                                       \
	XX(402, PAYMENT_REQUIRED, Payment Required)                               \
	XX(403, FORBIDDEN, Forbidden)                                             \
	XX(404, NOT_FOUND, Not Found)                                             \
	XX(405, METHOD_NOT_ALLOWED, Method Not Allowed)                           \
	XX(406, NOT_ACCEPTABLE, Not Acceptable)                                   \
	XX(407, PROXY_AUTHENTICATION_REQUIRED, Proxy Authentication Required)     \
	XX(408, REQUEST_TIMEOUT, Request Timeout)                                 \
	XX(409, CONFLICT, Conflict)                                               \
	XX(410, GONE, Gone)                                                       \
	XX(411, LENGTH_REQUIRED, Length Required)                                 \
	XX(412, PRECONDITION_FAILED, Precondition Failed)                         \
	XX(413, PAYLOAD_TOO_LARGE, Payload Too Large)                             \
	XX(414, URI_TOO_LONG, URI Too Long)                                       \
	XX(415, UNSUPPORTED_MEDIA_TYPE, Unsupported Media Type)                   \
	XX(416, RANGE_NOT_SATISFIABLE, Range Not Satisfiable)                     \
	XX(417, EXPECTATION_FAILED, Expectation Failed)                           \
	XX(421, MISDIRECTED_REQUEST, Misdirected Request)                         \
	XX(422, UNPROCESSABLE_ENTITY, Unprocessable Entity)                       \
	XX(423, LOCKED, Locked)                                                   \
	XX(424, FAILED_DEPENDENCY, Failed Dependency)                             \
	XX(426, UPGRADE_REQUIRED, Upgrade Required)                               \
	XX(428, PRECONDITION_REQUIRED, Precondition Required)                     \
	XX(429, TOO_MANY_REQUESTS, Too Many Requests)                             \
	XX(431, REQUEST_HEADER_FIELDS_TOO_LARGE, Request Header Fields Too Large) \
	XX(451, UNAVAILABLE_FOR_LEGAL_REASONS, Unavailable For Legal Reasons)     \
	XX(500, INTERNAL_SERVER_ERROR, Internal Server Error)                     \
	XX(501, NOT_IMPLEMENTED, Not Implemented)                                 \
	XX(502, BAD_GATEWAY, Bad Gateway)                                         \
	XX(503, SERVICE_UNAVAILABLE, Service Unavailable)                         \
	XX(504, GATEWAY_TIMEOUT, Gateway Timeout)                                 \
	XX(505, HTTP_VERSION_NOT_SUPPORTED, HTTP Version Not Supported)           \
	XX(506, VARIANT_ALSO_NEGOTIATES, Variant Also Negotiates)                 \
	XX(507, INSUFFICIENT_STORAGE, Insufficient Storage)                       \
	XX(508, LOOP_DETECTED, Loop Detected)                                     \
	XX(510, NOT_EXTENDED, Not Extended)                                       \
	XX(511, NETWORK_AUTHENTICATION_REQUIRED, Network Authentication Required)

		/* Request Methods */
#define HTTP_METHOD_MAP(XX)          \
	XX(0, DELETE, DELETE)            \
	XX(1, GET, GET)                  \
	XX(2, HEAD, HEAD)                \
	XX(3, POST, POST)                \
	XX(4, PUT, PUT)                  \
	/* pathological */               \
	XX(5, CONNECT, CONNECT)          \
	XX(6, OPTIONS, OPTIONS)          \
	XX(7, TRACE, TRACE)              \
	/* WebDAV */                     \
	XX(8, COPY, COPY)                \
	XX(9, LOCK, LOCK)                \
	XX(10, MKCOL, MKCOL)             \
	XX(11, MOVE, MOVE)               \
	XX(12, PROPFIND, PROPFIND)       \
	XX(13, PROPPATCH, PROPPATCH)     \
	XX(14, SEARCH, SEARCH)           \
	XX(15, UNLOCK, UNLOCK)           \
	XX(16, BIND, BIND)               \
	XX(17, REBIND, REBIND)           \
	XX(18, UNBIND, UNBIND)           \
	XX(19, ACL, ACL)                 \
	/* subversion */                 \
	XX(20, REPORT, REPORT)           \
	XX(21, MKACTIVITY, MKACTIVITY)   \
	XX(22, CHECKOUT, CHECKOUT)       \
	XX(23, MERGE, MERGE)             \
	/* upnp */                       \
	XX(24, MSEARCH, M - SEARCH)      \
	XX(25, NOTIFY, NOTIFY)           \
	XX(26, SUBSCRIBE, SUBSCRIBE)     \
	XX(27, UNSUBSCRIBE, UNSUBSCRIBE) \
	/* RFC-5789 */                   \
	XX(28, PATCH, PATCH)             \
	XX(29, PURGE, PURGE)             \
	/* CalDAV */                     \
	XX(30, MKCALENDAR, MKCALENDAR)   \
	/* RFC-2068, section 19.6.1.2 */ \
	XX(31, LINK, LINK)               \
	XX(32, UNLINK, UNLINK)           \
	/* icecast */                    \
	XX(33, SOURCE, SOURCE)

		enum class HttpMethod
		{
#define XX(num, name, string) name = num,
			HTTP_METHOD_MAP(XX)
#undef XX
				INVALID_METHOD
		};

		enum class HttpStatus
		{
#define XX(code, name, desc) name = code,
			HTTP_STATUS_MAP(XX)
#undef XX
		};

		HttpMethod StringToHttpMethod(const std::string &m);
		HttpMethod CharsToHttpMethod(const char *m);
		const char *HttpMethodToString(const HttpMethod &m);
		const char *HttpStatusToString(const HttpStatus &s);

		struct CaseInsensitiveLess
		{
			bool operator()(const std::string &lhs, const std::string &rhs) const;
		};

		template <class MapType, class T>
		bool checkGetAs(const MapType &m, const std::string &key, T &val, const T &def = T())
		{
			std::string str;
			auto it = m.find(key);
			if (it == m.end())
			{
				val = def;
				return false;
			}
			try
			{
				val = boost::lexical_cast<T>(it->second);
				return true;
			}
			catch (...)
			{
				val = def;
			}
			return false;
		}

		template <class MapType, class T>
		T getAs(const MapType &m, const std::string &key, const T &def = T())
		{
			auto it = m.find(key);
			if (it == m.end())
			{
				return def;
			}
			try
			{
				return boost::lexical_cast<T>(it->second);
			}
			catch (...)
			{
			}
			return def;
		}

		class HttpRequest
		{
		public:
			using ptr = std::shared_ptr<HttpRequest>;
			using MapType = std::map<std::string, std::string, CaseInsensitiveLess>;
			HttpRequest(uint8_t version = 0x11, bool close = true);

			HttpMethod getMethod() const { return _method; }
			uint8_t getVersion() const { return _version; }
			const std::string &getPath() const { return _path; }
			const std::string &getQuery() const { return _query; }
			const std::string &getBody() const { return _body; }
			

			const MapType &getHeaders() const { return _headers; }
			const MapType &getParams() const { return _params; }
			const MapType &getCookies() const { return _cookies; }

			void setMethod(HttpMethod v) { _method = v; }
			void setVersion(uint8_t v) { _version = v; }

			void setPath(const std::string &v) { _path = v; }
			void setQuery(const std::string &v) { _query = v; }
			void setFragment(const std::string &v) { _fragment = v; }
			void setBody(const std::string &v) { _body = v; }

			void setHeaders(const MapType &v) { _headers = v; }
			void setParams(const MapType &v) { _params = v; }
			void setCookies(const MapType &v) { _cookies = v; }

			std::string getHeader(const std::string &key, const std::string &def = "") const;
			std::string getParam(const std::string &key, const std::string &def = "");
			std::string getCookie(const std::string &key, const std::string &def = "");

			void setHeader(const std::string &key, const std::string &val);
			void setParam(const std::string &key, const std::string &val);
			void setCookie(const std::string &key, const std::string &val);
			void setWebsocket(bool v) { _websocket = v;}

			bool isWebsocket() const { return _websocket;} 
			bool isClose() const { return _close; }
			void setClose(bool v) { _close = v; }

			void delHeader(const std::string &key);
			void delParam(const std::string &key);
			void delCookie(const std::string &key);

			bool hasHeader(const std::string &key, std::string *val = nullptr);
			bool hasParam(const std::string &key, std::string *val = nullptr);
			bool hasCookie(const std::string &key, std::string *val = nullptr);

			template <class T>
			bool checkGetHeaderAs(const std::string &key, T &val, const T &def = T())
			{
				return checkGetAs(_headers, key, val, def);
			}
			template <class T>
			T getHeaderAs(const std::string &key, const T &def = T())
			{
				return getAs(_headers, key, def);
			}

			template <class T>
			bool checkGetParamAs(const std::string &key, T &val, const T &def = T())
			{
				initQueryParam();
				initBodyParam();
				return checkGetAs(_params, key, val, def);
			}
			template <class T>
			T getParamAs(const std::string &key, const T &def = T())
			{
				initQueryParam();
				initBodyParam();
				return getAs(_params, key, def);
			}

			template <class T>
			bool checkGetCookieAs(const std::string &key, T &val, const T &def = T())
			{
				initCookies();
				return checkGetAs(_cookies, key, val, def);
			}
			template <class T>
			T getCookieAs(const std::string &key, const T &def = T())
			{
				initCookies();
				return getAs(_cookies, key, def);
			}

			std::ostream &dump(std::ostream &os);
			std::string toString();

			void init();
			void initParam();
			void initQueryParam();
			void initBodyParam();
			void initCookies();

		private:
			HttpMethod _method;
			uint8_t _version;
			bool _close;
			bool _websocket;

			std::string _path;
			std::string _query;
			std::string _fragment;
			std::string _body;

			MapType _headers;
			MapType _params;
			MapType _cookies;

			uint8_t _parserParamFlag;
		};

		class HttpResponse
		{
		public:
			using ptr = std::shared_ptr<HttpResponse>;
			using MapType = std::map<std::string, std::string, CaseInsensitiveLess>;

			HttpResponse(uint8_t version = 0x11, bool close = true);

			HttpStatus getStatus() const { return _status; }
			uint8_t getVersion() const { return _version; }
			const std::string &getBody() const { return _body; }
			const std::string &getReason() const { return _reason; }
			const MapType &getHeaders() const { return _headers; }
			const std::vector<std::string>& getCookies() const { return _cookies;}

			void setStatus(HttpStatus v) { _status = v; }
			void setVersion(uint8_t v) { _version = v; }
			void setBody(const std::string &v) { _body = v; }
			void setReason(const std::string &v) { _reason = v; }
			void setHeaders(const MapType &v) { _headers = v; }
			void setWebsocket(bool v) { _websocket = v;}
			void setCookie(const std::string& key, const std::string& val
						, time_t expired = 0, const std::string& path = ""
                   		, const std::string& domain = "", bool secure = false);
			void setCookies(const std::vector<std::string>& v) { _cookies = v;}

			bool isWebsocket() const { return _websocket;} 
			bool isClose() const { return _close; }
			void setClose(bool v) { _close = v; }

			std::string getHeader(const std::string &key, const std::string &def = "") const;
			void setHeader(const std::string &key, const std::string &val);
			void delHeader(const std::string &key);

			template <class T>
			bool checkGetHeaderAs(const std::string &key, T &val, const T &def = T())
			{
				return checkGetAs(_headers, key, val, def);
			}
			template <class T>
			T getHeaderAs(const std::string &key, const T &def = T())
			{
				return getAs(_headers, key, def);
			}

			std::ostream &dump(std::ostream &os);			
			std::string toString();

		private:
			HttpStatus _status;
			uint8_t _version;
			bool _close;
			bool _websocket;

			std::string _body;
			std::string _reason;
			MapType _headers;
			std::vector<std::string> _cookies;
		};

	}
}

#endif
